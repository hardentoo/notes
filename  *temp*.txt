data Generator s = Generator
newtype Generatee s = Generatee Integer deriving (Eq, Ord)

newGenerator :: Generator s
newGenerator = Generator

generate :: Generator s -> (Generator s, Generatee s)
generate g = (g, Generatee 10)

reduce :: Generatee s -> Integer
reduce (Generatee num) = num

sourceGenerator
    :: Monad m
    => ((forall s. Generator s -> Source m (Generatee s)) -> Source m a)
    -> Source m a
sourceGenerator f = f $ \gen -> source (go gen)
  where
    go start z yield = loop start z
      where
        loop gen r =
            let (gen', g) = generate gen
            in yield r g >>= loop gen'

test_ :: IO ()
test_ = do
    z <- flip evalStateT (100 :: Int) $ sinkList $ sourceGenerator $ \f -> do
        x <- f newGenerator
        y <- f newGenerator
        cnt <- lift get
        if cnt == 0
            then abort
            else lift $ modify pred
        return (x < y)
    print z
